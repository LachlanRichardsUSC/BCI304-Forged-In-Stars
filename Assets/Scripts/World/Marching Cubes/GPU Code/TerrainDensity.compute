#pragma kernel CSMain
#include "Noise.hlsl"

// Texture for storing density values
RWTexture3D<float> DensityTexture;
int textureSize;
int borderWidth;

// Generation parameters
float boundsSize;
float noiseScale;
float noiseHeightMultiplier;
float terrainSeed;
float borderFalloffStart;
float borderFalloffSteepness;
int enableBorderFalloff;
float terrainGradient;

// Terrain zone parameters
float flatnessThreshold; // Controls how much terrain is flat (0-1)
float detail3DStrength; // Controls strength of 3D features (0-1)
float flatAreaCurve = 0.8; // Controls flatness transition curve
float detailAreaCurve = 0.7; // Controls detail transition curve

// Improved FBM (Fractal Brownian Motion) function with optimizations
// - Reduces horizontal artifacts at low noise scales 
// - Uses rotation and offset to break up grid patterns
float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos, float seedOffset = 0)
{
    // Initialize noise accumulator and frequency parameters
    float noise = 0;
    float baseFreq = max(1.0, scale) / 100.0; // Increase base frequency for low scales
    float frequency = baseFreq;
    float amplitude = 1;
    
    // Create rotation matrix to break up grid alignment (30 degrees around Y axis)
    float3x3 rotMatrix = float3x3(
        0.8660254, 0.0, 0.5,
        0.0, 1.0, 0.0,
        -0.5, 0.0, 0.8660254
    );
    
    // Apply initial rotation once, outside the loop for efficiency
    float3 rotatedPos = mul(rotMatrix, pos);
    
    // Accumulate noise layers
    for (int i = 0; i < numLayers; i++)
    {
        // Add prime number offsets to reduce pattern visibility
        float3 offsetPos = rotatedPos + float3(i * 31.13, i * 47.53, i * 13.71);
        
        // Generate noise value
        float n = 1 - abs(snoiseseed(offsetPos * frequency, float(terrainSeed + seedOffset + i)) * 2.0 - 1.0);
        
        // Apply domain warping for low frequencies to break up patterns
        if (scale <= 1.2 && i < 3)
        {
            float3 warp = float3(
                sin(offsetPos.x * 0.5 + offsetPos.z * 0.3) * 0.2,
                cos(offsetPos.y * 0.4 + offsetPos.x * 0.7) * 0.2,
                sin(offsetPos.z * 0.6 + offsetPos.y * 0.2) * 0.2
            );
            float nWarped = 1 - abs(snoiseseed((offsetPos + warp) * frequency,
                             float(terrainSeed + seedOffset + i + 100)) * 2.0 - 1.0);
            n = lerp(n, nWarped, 0.6);
        }
        
        // Add weighted noise to total
        noise += n * amplitude;
        
        // Vary frequency multipliers slightly for each octave to reduce repetition
        float freqMultiplier = lacunarity;
        if (i == 1)
            freqMultiplier = lacunarity * 0.97;
        else if (i == 2)
            freqMultiplier = lacunarity * 1.03;
        else if (i == 3)
            freqMultiplier = lacunarity * 0.99;
        
        // Update parameters for next octave
        frequency *= freqMultiplier;
        amplitude *= persistence;
        
        // Apply subtle rotation to further break up patterns
        rotatedPos = mul(rotMatrix, rotatedPos);
    }
    
    return noise;
}

// Calculates terrain density value for a given cell position
// Combines heightmap, flatness masks, and 3D details
float calculateDensity(int3 cell)
{
    // Convert cell position to world space
    float3 worldPos = (cell / float(textureSize - 1.0f) - 0.5f) * boundsSize;
    
    // Calculate border falloff
    float2 normalizedPos = float2(cell.x, cell.z) / float(textureSize - 1);
    float2 distFromCenter = abs(normalizedPos - 0.5) * 2.0; // 0 at center, 1 at edge
    float distFromEdge = 1.0 - max(distFromCenter.x, distFromCenter.y);
    
    // Apply border falloff if enabled
    float falloffFactor = 1.0;
    if (enableBorderFalloff != 0)
    {
        falloffFactor = smoothstep(0.0, borderFalloffStart, distFromEdge);
        falloffFactor = pow(max(0.0, falloffFactor), borderFalloffSteepness);
    }
    
    // 1. Generate base terrain heightmap
    float2 xzPosition = float2(worldPos.x, worldPos.z);
    float terrainHeight = fbm(5, 2.0, 0.5, noiseScale, float3(xzPosition.x, 0, xzPosition.y))
                          * noiseHeightMultiplier;
    
    // Center the noise distribution
    terrainHeight -= noiseHeightMultiplier * 0.5;
    
    // 2. Generate flatness mask to create varied terrain zones
    float rawFlatnessMask = fbm(2, 1.8, 0.4, noiseScale * 0.3, float3(xzPosition.x, 0, xzPosition.y), 500);
    float flatnessMask = smoothstep(0.3, 0.7, rawFlatnessMask);
    
    // Calculate effective threshold based on user parameter
    float effectiveThreshold = 0.2 + flatnessThreshold * 0.6;
    
    // 3. Apply plateau effect to flat areas
    if (flatnessMask > effectiveThreshold)
    {
        // Calculate smoothing factor with proper curve
        float smoothFactor = (flatnessMask - effectiveThreshold) / (1.0 - effectiveThreshold);
        smoothFactor = pow(max(0.0, smoothFactor), flatAreaCurve);
        
        // Sample neighboring positions for smooth height blending
        float smoothedHeight = 0;
        float totalWeight = 0;
        
        for (int dx = -1; dx <= 1; dx++)
        {
            for (int dz = -1; dz <= 1; dz++)
            {
                if (abs(dx) + abs(dz) <= 1) // Only cardinal directions + center
                {
                    float2 samplePos = xzPosition + float2(dx, dz) * 5.0;
                    float weight = 1.0 / (1.0 + (abs(dx) + abs(dz)));
                    
                    // Sample height at offset position
                    float sampleHeight = fbm(5, 2.0, 0.5, noiseScale,
                                        float3(samplePos.x, 0, samplePos.y)) * noiseHeightMultiplier;
                    sampleHeight -= noiseHeightMultiplier * 0.5;
                    
                    smoothedHeight += sampleHeight * weight;
                    totalWeight += weight;
                }
            }
        }
        
        // Apply smoothed height
        smoothedHeight /= totalWeight;
        terrainHeight = lerp(terrainHeight, smoothedHeight, smoothFactor);
        
        // Create plateau effect by rounding to height intervals
        float intervalSize = noiseHeightMultiplier * 0.2;
        float targetFlatHeight = round(terrainHeight / intervalSize) * intervalSize;
        terrainHeight = lerp(terrainHeight, targetFlatHeight, smoothFactor * 0.8);
    }
    
    // 4. Apply 3D detail to non-flat areas
    float detail3D = 0;
    float nonFlatThreshold = 1.0 - effectiveThreshold * 0.5;
    
    if (flatnessMask < nonFlatThreshold)
    {
        // More detail in less flat areas
        float nonFlatFactor = 1.0 - (flatnessMask / nonFlatThreshold);
        nonFlatFactor = pow(max(0.0, nonFlatFactor), detailAreaCurve);
        
        // Add medium scale details
        detail3D = fbm(4, 2.1, 0.5, noiseScale * 2.5, worldPos, 100)
                 * (noiseHeightMultiplier * detail3DStrength) * nonFlatFactor;
        
        // Add dramatic features in very non-flat areas (mountain peaks, cliffs)
        if (flatnessMask < 0.3)
        {
            float dramaticFactor = 1.0 - (flatnessMask / 0.3);
            float dramaticDetail = fbm(3, 2.2, 0.6, noiseScale * 3.0, worldPos, 200)
                               * (noiseHeightMultiplier * detail3DStrength * 1.5) * dramaticFactor;
            detail3D += dramaticDetail;
        }
    }
    
    // Apply border falloff to terrain features
    terrainHeight *= falloffFactor;
    
    // 5. Calculate final density (removed unnecessary baseHeight variable)
    float heightDifference = terrainHeight - worldPos.y;
    float gradient = boundsSize * terrainGradient;
    float density = heightDifference / gradient;
    
    // Add 3D detail with falloff applied
    density += detail3D * falloffFactor;
    
    return density;
}

[numthreads(8, 8, 8)]
void CSMain(int3 id : SV_DispatchThreadID)
{
    // Early exit if outside texture bounds
    if (id.x >= textureSize || id.y >= textureSize || id.z >= textureSize)
    {
        return;
    }

    float density;

    // Create solid bottom layer for stability
    if (id.y <= borderWidth)
    {
        density = 5.0; // Solid density
    }
    // Create empty top layer (air)
    else if (id.y >= textureSize - borderWidth)
    {
        density = -5.0; // Air density
    }
    else
    {
        // Normal terrain generation with border falloff
        density = calculateDensity(id);
    }

    // Store calculated density
    DensityTexture[id] = density;
}