// Density.compute: A compute shader that generates a 3D density texture for procedural terrain using noise.
// The shader computes density values based on a combination of a spherical base field and Fractal Brownian Motion (FBM) noise.
// The resulting density values are stored in a 3D texture, which is used for terrain generation with the marching cubes algorithm.

#pragma kernel CSMain
#include "Noise.hlsl"

// Texture for storing density values
RWTexture3D<float> DensityTexture;
int textureSize;
int borderWidth;

// Generation parameters
float planetSize;
float noiseScale;
float noiseHeightMultiplier;
float terrainSeed;
float borderFalloffStart;
float borderFalloffSteepness;
int enableBorderFalloff;

float flatnessThreshold; // Controls how much terrain is flat (0-1)
float detail3DStrength; // Controls strength of 3D features (0-1)

// Improved FBM function that reduces horizontal artifacts at low noise scales

float fbm(int numLayers, float lacunarity, float persistence, float scale, float3 pos, float seedOffset = 0)
{
    float noise = 0;
    
    // When scale is low, increase the initial frequency to avoid grid artifacts
    float baseFreq = max(1.0, scale) / 100.0;
    float frequency = baseFreq;
    float amplitude = 1;
    
    // Apply a rotation matrix to break up the grid alignment
    // This is especially important at low scales
    float3x3 rotMatrix = float3x3(
        0.8660254, 0.0, 0.5, // 30 degrees around Y
        0.0, 1.0, 0.0,
        -0.5, 0.0, 0.8660254
    );
    
    float3 rotatedPos = pos;
    
    for (int i = 0; i < numLayers; i++)
    {
        // Apply subtle rotation to break up horizontal patterns
        rotatedPos = mul(rotMatrix, rotatedPos);
        
        // Add some prime number offsets to further reduce pattern visibility
        float3 offsetPos = rotatedPos + float3(i * 31.13, i * 47.53, i * 13.71);
        
        // Use your existing noise function with seed
        float n = 1 - abs(snoiseseed(offsetPos * frequency, float(terrainSeed + seedOffset + i)) * 2.0 - 1.0);
        
        // Apply domain warping for low frequencies to break up patterns
        if (scale <= 1.2 && i < 3)
        {
            float3 warp = float3(
                sin(offsetPos.x * 0.5 + offsetPos.z * 0.3) * 0.2,
                cos(offsetPos.y * 0.4 + offsetPos.x * 0.7) * 0.2,
                sin(offsetPos.z * 0.6 + offsetPos.y * 0.2) * 0.2
            );
            float nWarped = 1 - abs(snoiseseed((offsetPos + warp) * frequency, float(terrainSeed + seedOffset + i + 100)) * 2.0 - 1.0);
            // Use HLSL's built-in lerp function instead of mix
            n = lerp(n, nWarped, 0.6);
        }
        
        noise += n * amplitude;
        
        // Use slightly different frequency multipliers for each octave
        float freqMultiplier = lacunarity;
        if (i == 1)
            freqMultiplier = lacunarity * 0.97;
        if (i == 2)
            freqMultiplier = lacunarity * 1.03;
        if (i == 3)
            freqMultiplier = lacunarity * 0.99;
        
        frequency *= freqMultiplier;
        amplitude *= persistence;
    }
    return noise;
}

float calculateDensity(int3 cell)
{
    // Convert cell position to world space
    float3 worldPos = (cell / float(textureSize - 1.0f) - 0.5f) * planetSize;
    
    // Calculate distance from edge for XZ border falloff
    float2 normalizedPos = float2(cell.x, cell.z) / float(textureSize - 1);
    float2 distFromCenter = abs(normalizedPos - 0.5) * 2.0; // 0 at center, 1 at edge
    float distFromEdge = 1.0 - max(distFromCenter.x, distFromCenter.y);
    
    // Create a falloff that starts at a certain distance from the edge
    float falloffFactor = 1.0;
    if (enableBorderFalloff != 0) // Check if border falloff is enabled
    {
        falloffFactor = smoothstep(0.0, borderFalloffStart, distFromEdge);
        falloffFactor = pow(falloffFactor, borderFalloffSteepness);
    }
    
    // 1. Create heightmap-based terrain foundation
    float2 xzPosition = float2(worldPos.x, worldPos.z);
    float terrainHeight = fbm(5, 2.0, 0.5, noiseScale, float3(xzPosition.x, 0, xzPosition.y)) * noiseHeightMultiplier;
    
    // Re-center the noise distribution by offsetting terrainHeight
    terrainHeight = terrainHeight - (noiseHeightMultiplier * 0.5);
    
    // 2. IMPROVED FLATNESS MASK - normalize the noise output
    // Generate base flatness noise
    float rawFlatnessMask = fbm(2, 1.8, 0.4, noiseScale * 0.3, float3(xzPosition.x, 0, xzPosition.y), 500);
    
    // Normalize to ensure better distribution (more values in middle range)
    float flatnessMask = smoothstep(0.3, 0.7, rawFlatnessMask);
    
    // Adjust threshold using flatnessThreshold parameter with better scaling
    float effectiveThreshold = 0.2 + flatnessThreshold * 0.6;
    
    // More prominent flat area effect
    if (flatnessMask > effectiveThreshold)
    {
        // Calculate smoothing factor with more dramatic effect
        float smoothFactor = (flatnessMask - effectiveThreshold) / (1.0 - effectiveThreshold);
        smoothFactor = pow(smoothFactor, 0.8); // Less steep curve for better gradient
        
        // Flat area smoothing code
        float smoothedHeight = 0;
        float totalWeight = 0;
        
        for (int dx = -1; dx <= 1; dx++)
        {
            for (int dz = -1; dz <= 1; dz++)
            {
                if (abs(dx) + abs(dz) <= 1)
                {
                    float2 samplePos = xzPosition + float2(dx, dz) * 5.0;
                    float weight = 1.0 / (1.0 + (abs(dx) + abs(dz)));
                    
                    // Apply the same offset to sample heights for consistency
                    float sampleHeight = fbm(5, 2.0, 0.5, noiseScale,
                                            float3(samplePos.x, 0, samplePos.y)) * noiseHeightMultiplier;
                    sampleHeight = sampleHeight - (noiseHeightMultiplier * 0.5);
                    
                    smoothedHeight += sampleHeight * weight;
                    totalWeight += weight;
                }
            }
        }
        
        smoothedHeight /= totalWeight;
        terrainHeight = lerp(terrainHeight, smoothedHeight, smoothFactor);
        
        // Make plateau effect more pronounced - adjust for the new centered approach
        float targetFlatHeight = round(terrainHeight / (noiseHeightMultiplier * 0.2))
                              * (noiseHeightMultiplier * 0.2);
        terrainHeight = lerp(terrainHeight, targetFlatHeight, smoothFactor * 0.8);
    }
    
    // 3. Modified 3D feature application to complement flatness effect
    float detail3D = 0;
    
    // Use complementary threshold for 3D features
    if (flatnessMask < (1.0 - effectiveThreshold * 0.5))
    {
        float nonFlatFactor = 1.0 - (flatnessMask / (1.0 - effectiveThreshold * 0.5));
        nonFlatFactor = pow(nonFlatFactor, 0.7); // Adjust curve for better effect
        
        // Use detail3DStrength parameter to control 3D feature intensity
        detail3D = fbm(4, 2.1, 0.5, noiseScale * 2.5, worldPos, 100)
                 * (noiseHeightMultiplier * detail3DStrength) * nonFlatFactor;
                  
        // More dramatic features in very non-flat areas
        if (flatnessMask < 0.3)
        {
            float dramaticFactor = 1.0 - (flatnessMask / 0.3);
            float dramaticDetail = fbm(3, 2.2, 0.6, noiseScale * 3.0, worldPos, 200)
                                 * (noiseHeightMultiplier * detail3DStrength * 1.5) * dramaticFactor;
            detail3D += dramaticDetail;
        }
    }
    
    // Apply border falloff to terrain height
    terrainHeight *= falloffFactor;
    
    // 4. Calculate final density with the modified height
    float baseHeight = 0.0;
    float finalHeight = baseHeight + terrainHeight;
    
    float heightDifference = finalHeight - worldPos.y;
    float gradient = planetSize * 0.03;
    float density = heightDifference / gradient;
    
    // Add 3D detail with falloff applied
    density += detail3D * falloffFactor;
    
    return density;
}


[numthreads(8, 8, 8)]
void CSMain(int3 id : SV_DispatchThreadID)
{
    // Early exit if outside texture bounds
    if (id.x >= textureSize || id.y >= textureSize || id.z >= textureSize)
    {
        return;
    }

    float density;

    // Keep bottom solid for stability
    if (id.y <= borderWidth)
    {
        density = 5.0; // Solid density
    }
    // Keep very top as air
    else if (id.y >= textureSize - borderWidth)
    {
        density = -5.0; // Air density
    }
    else
    {
        // Normal terrain generation with border falloff applied
        density = calculateDensity(id);
    }

    // Store calculated density
    DensityTexture[id] = density;
}